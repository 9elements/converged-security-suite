// Code generated by man/gen/gen.go. DO NOT EDIT.
package data

var Data = "{\"ansi\":\"Print ansi escape sequences.\\n\\nSynopsis:\\n    ansi COMMAND\\n\\nOptions:\\n    COMMAND must be one of:\\n        - clear: clear the screen and reset the cursor position\\n\\nAuthor:\\n    Manoel Vilela \\u003cmanoel_vilela@engineer.com\\u003e\",\"archive\":\"Archive archives files.\\n\\n\\nSynopsis:\\n    archive d|e|t [-d] [args...]\\n\\nDescription:\\n    The VTOC is at the front; we're not modeling tape drives or streams as\\n    in tar and cpio. This will greatly speed up listing the archive,\\n    modifying it, and so on. We think. Why a new tool?\\n\\nOptions:\\n    d: decode\\n    e: toc (table of contents)\\n    t: toc (table of contents)\\n    -d: debug prints\",\"basename\":\"Basename return name with leading path information removed.\\n\\nSynopsis:\\n    basename NAME [SUFFIX]\",\"boot\":\"boot allows to handover a system running linuxboot/u-root\\nto a legacy preinstalled operating system by replacing the traditional\\nbootloader path\\n\\nSynopsis:\\n\\tboot [-dev][-v][-dryrun]\\n\\nDescription:\\n\\tIf returns to u-root shell, the code didn't found a local bootable option\\n     -dev glob to use; default is /sys/class/block/*\\n     -v prints messages\\n     -dryrun doesn't really boot\\n\\nNotes:\\n\\tThe code is looking for boot/grub/grub.cfg file as to identify the\\n\\tboot option.\\n\\tThe first bootable device found in the block device tree is the one used\\n\\tWindows is not supported (that is a work in progress)\\n\\nExample:\\n\\tboot -v \\t- Start the script in verbose mode for debugging purpose\",\"bzimage\":\"bzImage is used to modify bzImage files.\\nIt reads the image in, applies an operator, and writes a new one out.\\n\\nSynopsis:\\n    bzImage [copy \\u003cin\\u003e \\u003cout\\u003e ] | [diff \\u003cimage\\u003e \\u003cimage\\u003e ] | [dump \\u003cfile\\u003e] | [initramfs input-bzimage initramfs output-bzimage]\\n\\nDescription:\\n\\tRead a bzImage in, change it, write it out, or print info.\",\"cat\":\"Cat concatenates files and prints to stdout.\\n\\nSynopsis:\\n    cat [-u] [FILES]...\\n\\nDescription:\\n    If no files are specified, read from stdin.\\n\\nOptions:\\n    -u: ignored flag\",\"cbmem\":\"cbmem prints out coreboot mem table information in JSON by default,\\nand also implements the basic cbmem -list and -console commands.\\nTODO: checksum tables.\",\"chmod\":\"Change modifier bits of a file.\\n\\nSynopsis:\\n    chmod MODE FILE...\\n\\nDesription:\\n    MODE is a three character octal value.\",\"chroot\":\"+build !windows !plan9\",\"cmp\":\"Cmp compares two files and prints a message if their contents differ.\\n\\nSynopsis:\\n    cmp [–lLs] FILE1 FILE2 [OFFSET1 [OFFSET2]]\\n\\nDescription:\\n    If offsets are given, comparison starts at the designated byte position\\n    of the corresponding file.\\n\\n    Offsets that begin with 0x are hexadecimal; with 0, octal; with anything\\n    else, decimal.\\n\\nOptions:\\n    –l: Print the byte number (decimal) and the differing bytes (octal) for\\n        each difference.\\n    –L: Print the line number of the first differing byte.\\n    –s: Print nothing for differing files, but set the exit status.\",\"comm\":\"Perform a set comparisons over two files.\\n\\nSynopsis:\\n    comm [-123h] FILE1 FILE2\\n\\nDescrption:\\n    Comm reads file1 and file2, which are in lexicographical order, and\\n    produces a three column output: lines only in file1; lines only in\\n    file2; and lines in both files. The file name – means the standard\\n    input.\\n\\nOptions:\\n    -1: suppress printing of column 1\\n    -2: suppress printing of column 2\\n    -3: suppress printing of column 3\\n    -h: print this help message and exit\",\"console\":\"console implements a basic console. It establishes a pair of files\\nto read from, the default being a UART at 0x3f8, but an alternative\\nbeing just stdin and stdout. It will also set up a root file system\\nusing util.Rootfs, although this can be disabled as well.\\nConsole uses a Go version of fork_pty to start up a shell, default\\n/ubin/elvish. Console runs until the shell exits and then exits itself.\",\"cp\":\"Copy files.\\n\\nSynopsis:\\n    cp [-rRfivwP] FROM... TO\\n\\nOptions:\\n    -w n: number of worker goroutines\\n    -R: copy file hierarchies\\n    -r: alias to -R recursive mode\\n    -i: prompt about overwriting file\\n    -f: force overwrite files\\n    -v: verbose copy mode\\n    -P: don't follow symlinks\",\"cpio\":\"cpio operates on cpio files using a cpio package\\nIt only implements basic cpio options.\\n\\n\\nSynopsis:\\n    cpio\\n\\nDescription:\\n\\nOptions:\\n    o: output an archive to stdout given a pattern\\n    i: output files from a stdin stream\\n    t: print table of contents\\n    -v: debug prints\\n\\nBugs: in i mode, it can't use non-seekable stdin, i.e. a pipe. Yep, this sucks.\\nBut if we implement seek on such things, we have to do it by reading, which\\nreally sucks. It's doable, we'll do it if we have to, but for now I'd like\\nto avoid the complexity. cpio is a 40 year old concept. If you want something\\nbetter, see ../archive which has a VTOC and separates data from metadata (unlike cpio).\\nWe could test for ESPIPE and fix it that way ... later.\",\"date\":\"Print the date.\\n\\nSynopsis:\\n    date [-u] [+format] | date [-u] [MMDDhhmm[CC]YY[.ss]]\",\"dd\":\"Convert and copy a file.\\n\\nSynopsis:\\n    dd [OPTIONS...] [-inName FILE] [-outName FILE]\\n\\nDescription:\\n    dd is modeled after dd(1).\\n\\nOptions:\\n    -ibs n:   input block size (default=1)\\n    -obs n:   output block size (default=1)\\n    -bs n:    input and output block size (default=0)\\n    -skip n:  skip n ibs-sized input blocks before reading (default=0)\\n    -seek n:  seek n obs-sized output blocks before writing (default=0)\\n    -conv s:  comma separated list of conversions (none|notrunc)\\n    -count n: copy only n ibs-sized input blocks\\n    -if:      defaults to stdin\\n    -of:      defaults to stdout\\n    -oflag:   comma separated list of out flags (none|sync|dsync)\\n    -status:  print transfer stats to stderr, can be one of:\\n        none:     do not display\\n        xfer:     print on completion (default)\\n        progress: print throughout transfer (GNU)\\n\\nNotes:\\n    Because UTF-8 clashes with block-oriented copying, `conv=lcase` and\\n    `conv=ucase` will not be supported. Additionally, research showed these\\n    arguments are rarely useful. Use tr instead.\",\"df\":\"df reports details of mounted filesystems\\n\\nSynopsis\\n df [-k] [-m]\\n\\nDescription\\n read mount information from /proc/mounts and\\n statfs syscall and display summary information for all\\n mount points that have a non-zero block count.\\n Users can choose to see the diplay in KB or MB.\\n\\nOptions\\n -k: display values in KB (default)\\n -m: dispaly values in MB\",\"dhclient\":\"dhclient sets up DHCP.\\n\\nSynopsis:\\n    dhclient [OPTIONS...]\\n\\nOptions:\\n    -timeout:  lease timeout in seconds\\n    -renewals: number of DHCP renewals before exiting\\n    -verbose:  verbose output\",\"dirname\":\"dirname prints out the directory name of one or more args.\\nIf no arg is given it returns an error and prints a message which,\\nper the man page, is incorrect, but per the standard, is correct.\",\"dmesg\":\"Read the system log.\\n\\nSynopsis:\\n    dmesg [-clear|-read-clear]\\n\\nOptions:\\n    -clear: clear the log\\n    -read-clear: clear the log after printing\",\"echo\":\"Echo writes its arguments separated by blanks and terminated by a newline on\\nthe standard output.\\n\\nSynopsis:\\n    echo [-e] [-n] [-E] [STRING]...\",\"ed\":\"ED(1)               Unix Programmer's Manual                ED(1)\\n\\nNAME\\n  ed - text editor\\n\\nSYNOPSIS\\n  ed [ - ] [ -d ] [ name ]\\n\\nDESCRIPTION\\n  Ed is the standard text editor.\\n\\nOPTIONS\",\"esxiboot\":\"esxiboot executes ESXi kernel over the running kernel.\\n\\nSynopsis:\\n    esxiboot --config \\u003cconfig\\u003e [-d (--device)]\\n\\nDescription:\\n    Loads and executes ESXi kernel.\\n\\nOptions:\\n    --device=FILE or -d=FILE: set the ESXi boot device\\n    --config=FILE or -c=FILE: set the ESXi config\\n\\n--device is required to kexec installed ESXi instance.\\nYou don't need it if you kexec ESXi installer.\\n\\nThe config file has the following syntax:\\n\\nkernel=PATH\\nkernelopt=OPTS\\nmodules=MOD1 [ARGS] --- MOD2 [ARGS] --- ...\\n\\nLines starting with '#' are ignored.\",\"false\":\"Returns 1.\\n\\nSynopsis:\\n    false\\n\\nDescription:\\n    Command line arguments are ignored.\",\"fdtdump\":\"fdtdump prints a readable version of Flattened Device Tree or dtb.\\n\\nSynopsis:\\n    fdtdump [-json] FILE\\n\\nOptions:\\n    -json: Print json with base64 encoded values.\",\"field\":\"The `field` command reads newline-separated lines of data from either\\nthe standard input or the specified files. It splits those lines into\\na list of fields, separated by a specifiable regular expression. It\\nthen prints all or a subset of those fields to the standard output.\\n\\nThe list of output fields is specified using a grammar given in the\\nparsing code, below.\\n\\nOptions '-F' and '-O' control the input and output separators,\\nrespectively. The NUL character can be used as an output separator if\\nthe '-0' is given. The '-e' and '-E' characters contol whether empty\\nfields are collapsed in the input; '-e' unconditionally preserves such\\nfields, '-E' discards them. If neither is specified, a heuristic is\\napplied to guess: if the input specifier is more than one character in\\nlength, we discard empty fields, otherwise we preserve them.\",\"find\":\"Find finds files. It is similar to the Unix command. It uses REs, not globs,\\nfor matching.\\n\\nOPTIONS:\\n    -d: enable debugging in the find package\\n    -mode integer-arg: match against mode, e.g. -mode 0755\\n    -type: match against a file type, e.g. -type f will match files\\n    -name: glob to match against file\\n    -l: long listing. It's not very good, yet, but it's useful enough.\",\"forth\":\"Forth is a forth interpreter.\\nIt reads a line at a time and puts it through the interpreter.\",\"free\":\"free reports usage information for physical memory and swap space.\\n\\nSynopsis:\\n    free [-k] [-m] [-g] [-t] [-h] [-json]\\n\\nDescription:\\n    Read memory information from /proc/meminfo and display a summary for\\n    physical memory and swap space. The unit options use powers of 1024.\\n\\nOptions:\\n    -k: display the values in kibibytes\\n    -m: display the values in mebibytes\\n    -g: display the values in gibibytes\\n    -t: display the values in tebibytes\\n    -h: display the values in human-readable form\\n    -json: use JSON output\",\"freq\":\"Freq reads the given files (default standard input) and prints histograms of the\\ncharacter frequencies. By default, freq counts each byte as a character; under\\nthe –r option it instead counts UTF sequences, that is, runes.\\n\\nSynopsis:\\n    freq [-rdxoc] [FILES]...\\n\\nDescription:\\n    Each non–zero entry of the table is printed preceded by the byte value,\\n    in decimal, octal, hex, and Unicode character (if printable). If any\\n    options are given, the –d, –x, –o, –c flags specify a subset of value\\n    formats: decimal, hex, octal, and character, respectively.\\n\\nOptions:\\n    –r: treat input as UTF-8\\n    –d: print decimal value\\n    –x: print hex value\\n    –o: print octal value\\n    –c: print character/UTF value\",\"fusermount\":\"+build linux\\nfusermount is a very limited replacement for the C fusermount.  It\\nis invoked by other programs, or interactively only to unmount.\\n\\nSynopsis:\\n    fusermount [-u|--unmount] [-z|--lazy] [-v|--verbose] \\u003cmountpoint\\u003e\\n\\nFor mounting, per the FUSE model, the environment variable\\n_FUSE_COMMFD must have the value of a file descriptor variable on\\nwhich we pass the fuse fd.\\n\\nThere is some checking we don't do, e.g. for the number of active\\nmount points.  Last time I checked, that's the kind of stuff\\nkernels do.\\n\\nDescription:\\n\\tinvoke fuse mount operations\",\"gpgv\":\"gpgv validates a signature against a file.\\n\\nSynopsis:\\n    gpgv [-v] KEY SIG CONTENT\\n\\nDescription:\\n    It prints \\\"OK\\\\n\\\" to stdout if the check succeeds and exits with 0. It\\n    prints an error message and exits with non-0 otherwise.\\n\\n    The openpgp package ReadKeyRing function does not completely implement\\n    RFC4880 in that it can't use a PublicSigningKey with 0 signatures. We\\n    use one from Eric Grosse instead.\\n\\nOptions:\\n    -v: verbose\\n\\nAuthor:\\n    grosse@gmail.com.\",\"gpt\":\"gpt reads and writes GPT headers.\\n\\nSynopsis:\\n    gpt [-w] file\\n\\nDescription:\\n    For -w, it reads a JSON formatted GPT from stdin, and writes 'file'\\n    which is usually a device. It writes both primary and secondary headers.\\n\\n    Otherwise it just writes the headers to stdout in JSON format.\",\"grep\":\"Concurrent, parallel grep.\\n\\nSynopsis:\\n    grep [-vrlq] [FILE]...\\n\\nDescription:\\n    It has to deal with the EMFILE limit. To do so we have one chan that is\\n    bounded. From args, we use filepath.Walk to generate a chan of names.\\n    From that, we create a chan of grepCommands. From that, we create a chan\\n    of grepResults. The grepResults contain matches or not-matches only. If\\n    we are in -l mode, the goprocs handling the grep bail out as soon as the\\n    condition is met. This grep is about 2x faster than GNU grep for simple\\n    non-recursive greps and slower as soon as filepath. Walk enters the\\n    picture. Let's fix this.\\n\\nOptions:\\n    -v: print only non-matching lines\\n    -r: recursive\\n    -l: list only files\\n    -q: don't print matches; exit on first match\",\"hexdump\":\"Prints files in hexadecimal.\\n\\nSynopsis:\\n    hexdump [FILES]...\\n\\nDescription:\\n    Concatenate the input files into a single hexdump. If there are no\\n    arguments, stdin is read.\",\"hostname\":\"Print the system's hostname.\\n\\nSynopsis:\\n    hostname\\n\\nAuthor:\\n    Beletti \\u003crhiguita@gmail.com\\u003e\",\"id\":\"Synopsis:\\n     id [-gGnu]\\n\\nDescription:\\n     id displays the uid, guid and groups of the calling process\\nOptions:\\n \\t\\t-g, --group     print only the effective group ID\\n\\t\\t  -G, --groups    print all group IDs\\n\\t\\t  -n, --name      print a name instead of a number, for -ugG\\n\\t\\t  -u, --user      print only the effective user ID\",\"init\":\"assumptions\\nwe've been booted into a ramfs with all this stuff unpacked and ready.\\nwe don't need a loop device mount because it's all there.\\nSo we run /go/bin/go build installcommand\\nand then exec /buildbin/sh\",\"io\":\"io reads and writes to physical memory and ports.\\n\\nSynopsis:\\n    io (r{b,w,l,q} address)...\\n    io (w{b,w,l,q} address value)...\\n    # x86 only:\\n    io (in{b,w,l} address)\\n    io (out{b,w,l} address value)...\\n\\nDescription:\\n    io lets you read/write 1/2/4/8-bytes to memory with the {r,w}{b,w,l,q}\\n    commands respectively.\\n\\n    On x86 platforms, {in,out}{b,w,l} allow for port io.\\n\\nExamples:\\n    # Read 8-bytes from address 0x10000 and 0x10000\\n    io rq 0x10000 rq 0x10008\\n    # Write to the serial port on x86\\n    io outb 0x3f8 50\",\"kill\":\"Kill kills processes.\\n\\nSynopsis:\\n    kill -l\\n    kill [\\u003c-s | --signal | -\\u003e \\u003cisgname|signum\\u003e] pid [pid...]\\n\\nOptions:\\n    -l:                       list the signal names\\n    -name, --signal name, -s: name is the message to send. On some systems\\n                              this is a string, on others a number. It is\\n                              optional and an OS-dependent value will be\\n                              used if it is not set. pid is a list of at\\n                              least one pid.\",\"lddfiles\":\"lddfiles prints the arguments and all .so dependencies of those arguments\\n\\nDescription:\\n\\tlddfiles prints the arguments on the command line and all .so's\\n\\ton which they depend. In some cases, those .so's are actually symlinks;\\n\\tin that case, the symlink and its value are printed.\\n\\tlddfiles can be used to package up a command for tranporation to\\n\\tanother machine, e.g.\\n\\tscp `lddfiles /usr/bin/*` remotehost:/\\n\\twill let you copy all of /usr/bin, and all needed libraries. to a remote\\n\\thost.\\n\\tlddfiles /usr/bin/* | cpio -H newc -o \\u003e /tmp/x.cpio\\n\\tlets you easily prepare cpio archives, which can be included in a kernel\\n\\tor similarly scp'ed to another machine.\",\"less\":\"less pages through a file\\n\\nSynopsis:\\n    less [OPTIONS] FILE\\n\\nOptions:\\n    -profile FILE: Save profile in this file\\n    -tabstop NUMBER: Number of spaces per tab\\n\\nKeybindings:\\n    Control:\\n\\n    * q: Quit\\n\\n    Scrolling:\\n\\n    * j: Scroll down\\n    * k: Scroll up\\n    * g: Scroll to top\\n    * G: Scroll to bottom\\n    * Pgdn: Scroll down one screen full\\n    * Pgup: Scroll up one screen full\\n    * ^D: Scroll down one half screen full\\n    * ^U: Scroll up one half screen full\\n\\n    Searching:\\n\\n    * /: Enter search regex (re2 syntax). Press enter to search.\\n    * n: Jump down to next search result\\n    * N: Jump up to previous search result\\n\\nAuthor:\\n    Michael Pratt (github.com/prattmic) whom we are forever grateful for\\n    writing https://github.com/prattmic/lesser.\",\"ln\":\"Ln makes links to files.\\n\\nSynopsis:\\n    ln [-svfTiLPrt] TARGET LINK\\n\\nOptions:\\n    -s: make symbolic links instead of hard links\\n    -v: print name of each linked file\\n    -f: remove destination files\\n    -T: treat linkname operand as a non-dir always\\n    -i: prompt if the user wants overwrite\\n    -L: dereference targets if are symbolic links\\n    -P: make hard links directly to symbolic links\\n    -r: create symlinks relative to link location\\n    -t: specify the directory to put the links\\n\\nAuthor:\\n    Manoel Vilela \\u003cmanoel_vilela@engineer.com\\u003e\",\"losetup\":\"Setup loop devices.\\n\\nSynopsis:\\n    losetup [-Ad] FILE\\n    losetup [-Ad] DEV FILE\\n\\nOptions:\\n    -A: pick any device\\n    -d: detach the device\",\"ls\":\"Ls prints the contents of a directory.\\n\\nSynopsis:\\n    ls [OPTIONS] [DIRS]...\\n\\nOptions:\\n    -l: long form\\n    -Q: quoted\\n    -R: equivalent to findutil's find\\n\\nBugs:\\n    With the `-R` flag, directories are only ever printed once.\",\"man\":\"man - print manual entry for command.\\n\\nSynopsis:\\n    man COMMAND\",\"mkdir\":\"Mkdir makes a new directory.\\n\\nSynopsis:\\n    mkdir [-m mode] [-v] [-p] DIRECTORY...\\n\\nOptions:\\n    -m: make all needed directories in the path\\n    -v: directory mode (ex: 666)\\n    -p: print each directory as it is made\",\"mkfifo\":\"mkfifo creates a named pipe.\\n\\nSynopsis:\\n    mkfifo [OPTIONS] NAME...\\n\\nOptions:\\n    -m: mode (default 0600)\",\"mknod\":\"Unmount a filesystem at the specified path.\\n\\nSynopsis:\\n    mknod PATH TYPE [MAJOR MINOR]\\n\\nDescription:\\n    Creates a special file at PATH of the given TYPE. If TYPE is b, c or u,\\n    the MAJOR and MINOR number must be specified. If the TYPE is p, they\\n    must not be specified.\",\"mktemp\":\"Mktemp makes a temporary file (or directory)\\n\\nSynopsis:\\n      mktemp [OPTION]... [TEMPLATE]\\n\\n      Create  a  temporary  file or directory, safely, and print its name.  TEMPLATE must contain at least 3 consecutive 'X's in last component.  If TEMPLATE is not specified, use tmp.XXXXXXXXXX, and --tmpdir is implied.  Files are\\n      created u+rw, and directories u+rwx, minus umask restrictions.\\n\\n      -d, --directory\\n             create a directory, not a file\\n\\n      -u, --dry-run\\n             do not create anything; merely print a name (unsafe)\\n\\n      -q, --quiet\\n             suppress diagnostics about file/dir-creation failure\\n\\n      --suffix=SUFF\\n             append SUFF to TEMPLATE; SUFF must not contain a slash.  This option is implied if TEMPLATE does not end in X\\n\\n      -p DIR, --tmpdir[=DIR]\\n             interpret TEMPLATE relative to DIR; if DIR is not specified, use $TMPDIR if set, else /tmp.  With this option, TEMPLATE must not be an absolute name; unlike with -t, TEMPLATE may contain  slashes,  but  mktemp  creates\\n             only the final component\",\"more\":\"More pages through files without any terminal trickery.\\n\\nSynopsis:\\n    more [OPTIONS] FILE\\n\\nDescription:\\n    Admittedly, this does not follow the conventions of GNU more. Instead,\\n    it is built with the goal of not relying on any special ttys, ioctls or\\n    special ANSI escapes. This is ideal when your terminal is already\\n    borked. For bells and whistles, look at less.\\n\\nOptions:\\n    --lines NUMBER: screen size in number of lines\",\"mount\":\"Mount a filesystem at the specified path.\\n\\nSynopsis:\\n    mount [-r] [-o options] [-t FSTYPE] DEV PATH\\n\\nOptions:\\n    -r: read only\",\"msr\":\"msr lets you read and write an msr for one or more cores.\\nThe cores are specified via a filepath.Glob string.\\nThe string should be for core number only, with no\\nsurrounding paths, e.g. you use 0 for core 0, not\\n/dev/cpu/0/msr.\\nTo specify all cores, use '*'\\nTo specify all cores with two digits, use '??'\\nTo specify all odd cores, use '*[13579]'\\nTo specify, e.g., all the even cores, use '*[02468]'.\\nUsage:\\nmsr r glob 32-bit-msr-number\\nmsr w glob 32-bit-msr-number 64-bit-value\\nFor each MSR operation msr will print an error if any.\\nIf your kernel does not have MSRs for any reason,\\nthis will fail due to file access. But it's quite possible\\nthat non-x86 architectures might someday implement MSRs,\\nwhich on (e.g.) PPC might have a slightly different name\\n(DICR) but would implement the same kinds of functions.\",\"mv\":\"Mv renames files and directories.\\n\\nSynopsis:\\n    mv SOURCE [-u] TARGET\\n    mv SOURCE... [-u] DIRECTORY\\n\\nAuthor:\\n    Beletti (rhiguita@gmail.com)\",\"netcat\":\"Netcat pipes over the network.\",\"ntpdate\":\"simple ntpd daemon in Go.\",\"pci\":\"pci: show pci bus vendor ids and other info\\n\\nDescription:\\n    List the PCI bus, with names if possible.\\n\\nOptions:\\n    -n: just show numbers\\n    -c: dump config space\\n    -s: specify glob for choosing devices.\",\"pe\":\"Dump the headers of a PE file.\\n\\nSynopsis:\\n    pe [FILENAME]\\n\\nDescription:\\n    Windows and EFI executables are in the portable executable (PE) format.\\n    This command prints the headers in a JSON format.\",\"ping\":\"Send icmp packets to a server to test network connectivity.\\n\\nSynopsis:\\n    ping [-hV] [-c COUNT] [-i INTERVAL] [-s PACKETSIZE] [-w DEADLINE] DESTINATION\\n\\nOptions:\\n    -6: use ipv6 (ip6:ipv6-icmp)\\n    -s: data size (default: 64)\\n    -c: # iterations, 0 to run forever (default)\\n    -i: interval in milliseconds (default: 1000)\\n    -V: version\\n    -w: wait time in milliseconds (default: 100)\\n    -h: help\",\"pox\":\"pox builds a portable executable as a squashfs image.\\nIt is intended to create files compatible with tinycore\\ntcz files. One of more of the files can be programs\\nbut that is not required.\\nThis could have been a simple program but mksquashfs does not\\npreserve path information.\\nYeah.\\n\\nSynopsis:\\n    pox [-[-debug]|d] -[-run|r file] [-[-create]|c]  [-[-file]|f tcz-file] file [...file]\\n\\nDescription:\\n    pox makes portable executables in squashfs format compatible with\\n    tcz format. We don't build in the execution code, rather, we set it\\n    up so we can use the command itself. You can create, create and run a command,\\n    mount a pox, or mount a pox and run a command in it.\\n\\nOptions:\\n    debug|d: verbose\\n    file|f file: file name (default /tmp/pox.tcz)\\n    run|r: run a file by loopback mounting the squashfs and using the first arg as a command to run in a chroot\\n    create|c: create the file.\\n    both -c and -r can be used on the same command.\\n\\nExample:\\n\\tpox -d -r /bin/bash /bin/cat /bin/ls /etc/hosts\\n\\tWill build a squashfs, mount it, and drop you into it running bash.\\n\\tYou can use ls and cat on /etc/hosts.\\n\\tSimpler example:\\n\\tpox -d -r /bin/ls /etc/hosts\\n\\twill run ls and exit.\",\"printenv\":\"Print environment variables.\\n\\nSynopsis:\\n    printenv\",\"ps\":\"Print process information.\\n\\nSynopsis:\\n    ps [-Aaex] [aux]\\n\\nDescription:\\n    ps reads the /proc filesystem and prints nice things about what it\\n    finds.  /proc in linux has grown by a process of Evilution, so it's\\n    messy.\\n\\nOptions:\\n    -A: select all processes. Identical to -e.\\n    -e: select all processes. Identical to -A.\\n    -x: BSD-Like style, with STAT Column and long CommandLine\\n    -a: print all process except whose are session leaders or unlinked with terminal\\n   aux: see every process on the system using BSD syntax\",\"pwd\":\"Print name of current directory.\\n\\nSynopsis:\\n    pwd [-LP]\\n\\nOptions:\\n    -P: don't follow symlinks\\n\\nAuthor:\\n    created by Beletti (rhiguita@gmail.com)\",\"readlink\":\"readlink display value of symbolic link file.\\n\\nSynopsis:\\n    readlink [OPTIONS] FILE\\n\\nOptions:\\n    -f: follow\\n    -v: verbose\",\"rm\":\"Delete files.\\n\\nSynopsis:\\n    rm [-Rrvif] FILE...\\n\\nOptions:\\n    -i: interactive mode\\n    -v: verbose mode\\n    -R: remove file hierarchies\\n    -r: equivalent to -R\\n    -f: ignore nonexistent files and never prompt\",\"rsdp\":\"rsdp allows to determine the ACPI RSDP structure address which could\\nbe passed to the boot command later on\\nIt must be executed at the system init as it relies on scanning\\nthe kernel messages which could be quickly filled up in some cases\\n\\nSynopsis:\\n\\trsdp [-f file]\\n\\nDescription:\\n\\tLook for rsdp value in a file, default /dev/kmsg\\n\\nExample:\\n\\trsdp\\n\\trsdp -f /path/to/file\",\"run\":\"Run executes its arguments as a Go program.\\n\\nSynopsis:\\n    run [-v] GO_CODE..\\n\\nExamples:\\n    run {fmt.Println(\\\"hello\\\")}\\n\\nOptions:\\n    -v: verbose display of processing\",\"rush\":\"Rush is an interactive shell similar to sh.\\n\\nDescription:\\n    Prompt is '% '.\",\"scp\":\"Scp copies files between hosts on a network.\\n\\nSynopsis:\\n    scp [-t|-f] [FILE]\\n\\nDescription:\\n    If -t is given, decode SCP protocol from stdin and write to FILE.\\n    If -f is given, stream FILE over SCP protocol to stdout.\\n\\nOptions:\\n    -t: Act as the target\\n    -f: Act as the source\\n    -v: Passed if SCP is verbose, ignored\",\"seq\":\"Print a sequence of numbers.\\n\\nSynopsis:\\n    seq [-f FORMAT] [-w] [-s SEPARATOR] [START [STEP [END]]]\\n\\nExamples:\\n   % seq -s=' ' 3\\n   1 2 3\\n   % seq -s=' ' 2 4\\n   2 3 4\\n   % seq -s=' ' 3 2 7\\n   3 5 7\\n\\nOptions:\\n    -f: use printf style floating-point FORMAT (default: %v)\\n    -s: use STRING to separate numbers (default: \\\\n)\\n    -w: equalize width by padding with leading zeroes (default: false)\",\"shutdown\":\"shutdown halts, suspends, or reboots.\\n\\nSynopsis:\\n    shutdown [-h|-r|halt|reboot|suspend]\\n\\nDescription:\\n    current operations are reboot (-r), suspend, and halt [-h].\\n\\nOptions:\\n    -r|reboot:\\treboot the machine.\\n    -h|halt:\\t\\thalt the machine.\\n    -s|suspend:\\tsuspend the machine.\",\"sleep\":\"Delay for the specified amount of time.\\n\\nSynopsis:\\n    sleep DURATION\\n\\nDescription:\\n    If no units are given, the duration is assumed to be measured in\\n    seconds, otherwise any format parsed by Go's `time.ParseDuration` is\\n    accepted.\\n\\nExamples:\\n    sleep 2.5\\n    sleep 300ms\\n    sleep 2h45m\\n\\nBugs:\\n    When sleep is first run, it must be compiled from source which creates a\\n    delay significantly longer than anticipated.\",\"sort\":\"Sort lines.\\n\\nSynopsis:\\n    sort [OPTIONS]... [INPUT]...\\n\\nDescription:\\n    Sort copies lines from the input to the output, sorting them in the\\n    process. This does nothing fancy (no multi-threading, compression,\\n    optiminzations, ...); it simply uses Go's sort.Sort function.\\n\\nOptions:\\n    -r:      reverse\\n    -o FILE: output file\",\"srvfiles\":\"Serve files on the network.\\n\\nSynopsis:\\n    srvfiles [--h=HOST] [--p=PORT] [--d=DIR]\\n\\nOptions:\\n    --h: hostname (default: 127.0.0.1)\\n    --p: port number (default: 8080)\\n    --d: directory to serve (default: .)\",\"strace\":\"strace is a simple multi-process tracer.\\nIt starts the comand and lets the strace.Run() do all the work.\\n\\nSynopsis:\\n    strace \\u003ccommand\\u003e [args...]\\n\\nDescription:\\n\\ttrace a single process given a command name.\",\"strings\":\"Strings finds printable strings.\\n\\nSynopsis:\\n    strings OPTIONS [FILES]...\\n\\nDescription:\\n    Prints all sequences of `n` or more printable characters terminated by a\\n    non-printable character (or EOF).\\n\\n    If no files are specified, read from stdin.\\n\\nOptions:\\n    -n number: the minimum string length (default is 4)\",\"stty\":\"stty is an stty command in Go.\\nIt follows many of the conventions of standard stty.\\nHowever, it can produce JSON output, for later use, and can\\nread that JSON later to configure it.\\n\\nstty has always had an odd set of flags. -flag means turn flag off;\\nflag means turn flag on. Except for those flags which make an argument;\\nin that case they look like flag \\u003carg\\u003e\\nTo make the flag package continue to work, we've changed the - to a ~.\\n\\nProgrammatically, the options are set with a []string, not lots of magic numbers that\\nare not portable across kernels.\\n\\nThe default action is to print in the model of standard stty, which is all most\\npeople ever do anyway.\\nThe command works like this:\\nstty [verb] [options]\\nVerbs are:\\ndump -- dump the json of the struct to stdout\\nload -- read a json file from stdin and use it to set\\nraw -- convenience command to set raw\\ncooked -- convenience command to set cooked\\nIn common stty usage, options may be specified without a verb.\\n\\nany other verb, with a ~ or without, is taken to mean standard stty args, e.g.\\nstty ~echo\\nturns off echo. Flags with arguments work too:\\nstty intr 1\\nsets the interrupt character to ^A.\\n\\nThe JSON encoding lets you do things like this:\\nstty dump | sed whatever \\u003e file\\nstty load file\\nFurther, one can easily push and pop state in by storing the current\\nstate in a file in JSON, making changes, and restoring it later. This has\\nalways been inconvenient in standard stty.\\n\\nWhile GNU stty can do some of this, its way of doing it is harder to read and not\\nas portable, since the format they use is not self-describing:\\nstty -g\\n4500:5:bf:8a3b:3:1c:7f:15:4:0:1:0:11:13:1a:0:12:f:17:16:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0\\n\\nWe always do our operations on fd 0, as that is standard, and we always do an initial\\ntermios.GTTY to ensure we have access to fd 0.\",\"sync\":\"sync command in Go.\",\"tac\":\"tac concatenates files and prints to stdout in reverse order,\\nfile by file\\n\\nSynopsis:\\n    tac \\u003cfile...\\u003e\\n\\nDescription:\\n\\nOptions:\",\"tail\":\"Tail prints the lasts 10 lines of a file. Can additionally follow the\\nthe end of the file as it grows.\\n\\nSynopsis:\\n    tail [-f] [-n lines_to_show] [FILE]\\n\\nDescription:\\n    If no files are specified, read from stdin.\\n\\nOptions:\\n    -f: follow the end of the file as it grows\\n    -n: specify the number of lines to show (default: 10)\\nMissing features:\\n- follow-mode (i.e. tail -f)\",\"tee\":\"Tee transcribes the standard input to the standard output and makes copies\\nin the files.\\n\\nSynopsis:\\n    tee [-ai] FILES...\\n\\nOptions:\\n    -a, --append: append the output to the files rather than rewriting them\\n    -i, --ignore-interrupts: ignore the SIGINT signal\",\"tr\":\"tr - translate or delete characters\\nSynopsis:\\n    tr [OPTION]... SET1 [SET2]\\nDescription:\\n    Translate, squeeze, and/or delete characters from standard input, writing\\n    to standard output.\\n\\n    -d, --delete: delete characters in SET1, do not translate\\n\\nSETs  are  specified  as  strings of characters. Most represent themselves.\\nInterpreted sequences are:\\n    \\\\\\\\        backslash\\n    \\\\a        audible BEL\\n    \\\\b        backspace\\n    \\\\f        form feed\\n    \\\\n        new line\\n    \\\\r        return\\n    \\\\t        horizontal tab\\n    \\\\v        vertical tab\\n    [:alnum:] all letters and digits\\n    [:alpha:] all letters\\n    [:digit:] all digits\\n    [:graph:] all printable characters\\n    [:cntrl:] all control characters\\n    [:lower:] all lower case letters\\n    [:upper:] all upper case letters\\n    [:space:] all whitespaces\",\"true\":\"Returns 0.\\n\\nSynopsis:\\n    true\\n\\nDescription:\\n    Command line arguments are ignored.\",\"truncate\":\"Truncate - shrink or extend the size of a file to the specified size\\n\\nSynopsis:\\n    truncate [OPTIONS] [FILE]...\\n\\nOptions:\\n    -s: size in bytes\\n    -c: do not create any files\\n\\nAuthor:\\n    Roland Kammerer \\u003cdev.rck@gmail.com\\u003e\",\"umount\":\"Unmount a filesystem at the specified path.\\n\\nSynopsis:\\n    umount [-f | -l] PATH\\n\\nOptions:\\n    -f: force unmount\\n    -l: lazy unmount\",\"uname\":\"Print build information about the kernel and machine.\\n\\nSynopsis:\\n    uname [-asnrvmd]\\n\\nOptions:\\n    -a: print everything\\n    -s: print the kernel name\\n    -n: print the network node name\\n    -r: print the kernel release\\n    -v: print the kernel version\\n    -m: print the machine hardware name\\n    -d: print your domain name\",\"uniq\":\"Uniq removes repeated lines.\\n\\nSynopsis:\\n    uniq [OPTIONS...] [FILES]...\\n\\nDescription:\\n    Uniq copies the input file, or the standard input, to the standard\\n    output, comparing adjacent lines. In the normal case, the second and\\n    succeeding copies of repeated lines are removed. Repeated lines must be\\n    adjacent in order to be found.\\n\\nOptions:\\n    –u:      Print unique lines.\\n    –d:      Print (one copy of) duplicated lines.\\n    –c:      Prefix a repetition count and a tab to each output line.\\n             Implies –u and –d.\\n    –f num:  The first num fields together with any blanks before each are\\n             ignored. A field is defined as a string of non–space, non–tab\\n             characters separated by tabs and spaces from its neighbors.\\n    -cn num: The first num characters are ignored. Fields are skipped before\\n             characters.\",\"unshare\":\"Disassociate parts of the process execution context.\\n\\nSynopsis:\\n    unshare [OPTIONS] [PROGRAM [ARGS]...]\\n\\nDescription:\\n    Go applications use multiple processes, and the Go user level scheduler\\n    schedules goroutines onto those processes. For this reason, it is not\\n    possible to use syscall.Unshare. A goroutine can call `syscall.Unshare`\\n    from process m and the scheduler can resume that goroutine in process n,\\n    which has not had the unshare operation! This is a known problem with\\n    any system call that modifies the name space or file system context of\\n    only one process as opposed to the entire Go application, i.e. all of\\n    its processes. Examples include chroot and unshare. There has been\\n    lively discussion of this problem but no resolution as of yet. In sum:\\n    it is not possible to use `syscall.Unshare` from Go with any reasonable\\n    expectation of success.\\n\\n    If PROGRAM is not specified, unshare defaults to /ubin/elvish.\\n\\nOptions:\\n    -ipc:           Unshare the IPC namespace\\n    -mount:         Unshare the mount namespace\\n    -pid:           Unshare the pid namespace\\n    -net:           Unshare the net namespace\\n    -uts:           Unshare the uts namespace\\n    -user:          Unshare the user namespace\\n    -map-root-user: Map current uid to root. Not working\",\"validate\":\"This program validates a file by verifying a checksum and a signature file.\\n\\nSynopsis:\\n    validate [OPTIONS...] FILE PUBLIC_KEY_FILE\\n\\nDescription:\\n    Return code: 0-OK, 1-Any error, 2-Bad signature, 3-Bad checksum\\n\\nOptions:\\n    -a:        signature is ASCII armored\\n    -i FILE:   checksum file\\n    -alg FILE: algorithms to check\\n    -v:        verbose\",\"wc\":\"Wc counts lines, words, runes, syntactically–invalid UTF codes.\\n\\nSynopsis:\\n    wc [OPTIONS...] [FILES]...\\n\\nDescription:\\n    Wc counts lines, words, runes, syntactically–invalid UTF codes and bytes\\n    in the named files, or in the standard input if no file is named. A word\\n    is a maximal string of characters delimited by spaces, tabs or newlines.\\n    The count of runes includes invalid codes. If the optional argument is\\n    present, just the specified counts (lines, words, runes, broken UTF\\n    codes or bytes) are selected by the letters l, w, r, b, or c. Otherwise,\\n    lines, words and bytes (–lwc) are reported.\\n\\nOptions:\\n    –l: count lines\\n    –w: count words\\n    –r: count runes\\n    –b: count broken UTF codes\\n    -c: count bytes\\n\\nBugs:\\n    This wc differs from Plan 9's wc somewhat in word count (BSD's wc differs\\n    even more significantly):\\n\\n    $ unicode 0x0-0x10ffff | 9 wc -w\\n    2228221\\n    $ unicode 0x0-0x10ffff | gowc -w\\n    2228198\\n    $ unicode 0x0-0x10ffff | bsdwc -w\\n    2293628\\n\\n    This wc differs from Plan 9's wc significantly in bad rune count:\\n\\n    $ unicode 0x0-0x10ffff | gowc -b\\n    6144\\n    $ unicode 0x0-0x10ffff | 9 wc -b\\n    1966080\",\"wget\":\"Wget reads one file from a url and writes to stdout.\\n\\nSynopsis:\\n    wget URL\\n\\nDescription:\\n    Returns a non-zero code on failure.\\n\\nNotes:\\n    There are a few differences with GNU wget:\\n    - Upon error, the return value is always 1.\\n    - The protocol (http/https) is mandatory.\\n\\nExample:\\n    wget -O google.txt http://google.com/\",\"which\":\"Which locates a command.\\n\\nSynopsis:\\n    which [-a] [COMMAND]...\\n\\nOptions:\\n    -a: print all matching pathnames of each argument\",\"zimage\":\"zimage dumps the header of a zImage.\\n\\nSynopsis:\\n    zimage FILE\\n\\nDescription:\\n    This is mainly for debugging purposes.\"}"
